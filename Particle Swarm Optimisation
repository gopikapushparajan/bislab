import numpy as np
from dataclasses import dataclass

# ---- Target (edit these if needed) ----
v0 = 5.0
b0 = 7.0

def objective(pos):
    v, b = pos
    return (v - v0) ** 2 + (b - b0) ** 2

@dataclass
class PSOConfig:
    n_particles: int = 30
    n_dim: int = 2
    iters: int = 10
    w: float = 0.7
    c1: float = 1.5
    c2: float = 1.5
    bounds: tuple = ((0.0, 10.0), (0.0, 10.0))
    vmax: float = 1.5
    seed: int = 123

class PSO:
    def __init__(self, cfg: PSOConfig, obj_fn):
        self.cfg = cfg
        self.obj = obj_fn
        self.rng = np.random.default_rng(cfg.seed)

        lows = np.array([cfg.bounds[d][0] for d in range(cfg.n_dim)])
        highs = np.array([cfg.bounds[d][1] for d in range(cfg.n_dim)])
        self.lows, self.highs = lows, highs

        self.pos = self.rng.uniform(lows, highs, size=(cfg.n_particles, cfg.n_dim))
        self.vel = self.rng.uniform(-cfg.vmax, cfg.vmax, size=(cfg.n_particles, cfg.n_dim))

        self.pbest_pos = self.pos.copy()
        self.pbest_val = np.apply_along_axis(self.obj, 1, self.pos)

        g_idx = int(np.argmin(self.pbest_val))
        self.gbest_pos = self.pbest_pos[g_idx].copy()
        self.gbest_val = float(self.pbest_val[g_idx])

    def _clip_bounds(self, arr):
        np.clip(arr, self.lows, self.highs, out=arr)

    def _clip_velocity(self, v):
        np.clip(v, -self.cfg.vmax, self.cfg.vmax, out=v)

    def step(self):
        r1 = self.rng.random((self.cfg.n_particles, self.cfg.n_dim))
        r2 = self.rng.random((self.cfg.n_particles, self.cfg.n_dim))

        cognitive = self.cfg.c1 * r1 * (self.pbest_pos - self.pos)
        social    = self.cfg.c2 * r2 * (self.gbest_pos - self.pos)

        self.vel = self.cfg.w * self.vel + cognitive + social
        self._clip_velocity(self.vel)

        self.pos += self.vel
        self._clip_bounds(self.pos)

        fvals = np.apply_along_axis(self.obj, 1, self.pos)

        improved = fvals < self.pbest_val
        self.pbest_pos[improved] = self.pos[improved]
        self.pbest_val[improved] = fvals[improved]

        g_idx = int(np.argmin(self.pbest_val))
        if self.pbest_val[g_idx] < self.gbest_val:
            self.gbest_val = float(self.pbest_val[g_idx])
            self.gbest_pos = self.pbest_pos[g_idx].copy()

    def run(self):
        for it in range(1, self.cfg.iters + 1):
            self.step()
            v, b = self.gbest_pos
            print(f"Iteration {it:02d}: Best position = [{v:.4f}, {b:.4f}], Best score = {self.gbest_val:.4f}")
        return self.gbest_pos, self.gbest_val

if __name__ == "__main__":
    cfg = PSOConfig(
        n_particles=30,
        iters=10,
        w=0.7,
        c1=1.5,
        c2=1.5,
        bounds=((0.0, 10.0), (0.0, 10.0)),
        vmax=1.5,
        seed=123
    )

    pso = PSO(cfg, objective)
    best_pos, best_score = pso.run()

    vol, bri = best_pos
    print("\nFinal Results")
    print("-------------")
    print(f"Optimal volume: {vol:.4f}")
    print(f"Optimal brightness: {bri:.4f}")
    print(f"Minimum function: {best_score:.4f}")
